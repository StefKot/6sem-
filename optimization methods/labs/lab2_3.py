import numpy as np
from scipy.optimize import linprog

# --- Определение параметров задачи на основе предоставленной таблицы ---

# Вектор стоимостей c для целевой функции (c^T x -> min)
# Значения взяты из столбца "Стоимость в час, $"
c = np.array([0.065, 0.130, 0.260, 0.165, 0.020])

# Названия типов ВМ (для более понятного вывода)
vm_names = ["m1.small", "m1.medium", "m1.large", "t1.micro", "c1.medium"]

# Матрица A (технические характеристики ВМ):
# Каждая строка соответствует одному из 5 типов ресурсов (N1-N5).
# Каждый столбец соответствует одному из 5 типов ВМ (согласно таблице).
# N1: vCPU
# N2: ECU
# N3: ОЗУ, ГБ
# N4: Устройство хранения, ГБ
# N5: Производительность сети (оценка)
A = np.array([
    [1,   1,    2,    2,    1   ],    # vCPU
    [1,   2,    4,    5,    1   ],    # ECU
    [1.7, 3.75, 7.5,  1.7,  0.615],  # ОЗУ, ГБ
    [160, 410,  820,  350,  0   ],    # Устройство хранения, ГБ
    [2,   3,    3,    3,    1   ]     # Производительность сети (2-низкая, 3-средняя, 1-очень низкая)
])

# Вектор b (минимальные требуемые ресурсы для приложения Δ):
# Эти значения взяты из предыдущего описания задачи.
# N1: 0.35 единиц vCPU
# N2: 1 ECU производительности
# N3: 0.256 Гб ОЗУ
# N4: 2 Гб для устройства хранения
# N5: Низкая производительность сети (соответствует значению 2)
b = np.array([0.35, 1, 0.256, 2, 2])

# Названия ресурсов для вывода
resource_names = [
    "N1 (vCPU)",
    "N2 (Произв. ECU)",
    "N3 (ОЗУ, Гб)",
    "N4 (Хранение, Гб)",
    "N5 (Произв. сети)"
]

# --- Преобразование для scipy.optimize.linprog ---
# Функция linprog решает задачу минимизации: min c^T x
# при ограничениях вида: A_ub * x <= b_ub
# Исходные ограничения: Ax >= b. Для преобразования умножаем на -1: -Ax <= -b.
A_ub = -A
b_ub = -b

# Границы для переменных x (x_i >= 0 для всех i):
# Количество переменных равно количеству типов ВМ (столбцов в A).
num_vm_types = A.shape[1]
x_bounds = [(0, None) for _ in range(num_vm_types)]

# --- Решение задачи линейного программирования ---
res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=x_bounds, method='highs')

# --- Вывод результатов ---
print("="*70)
print("Результаты оптимизации распределения виртуальных ресурсов в ЦОД")
print("="*70)

if res.success:
    print("Статус решения: Оптимальное решение найдено.")
    print("-" * 40)
    print("Оптимальные значения переменных (количество экземпляров ВМ):")
    for i in range(num_vm_types):
        print(f"  x{i+1} ({vm_names[i]:<10}): {res.x[i]:.6f} экземпляров")
    print("-" * 40)
    print(f"Минимальное значение целевой функции (стоимость в час, $): {res.fun:.6f}")
    print("-" * 40)
    print("Проверка удовлетворения минимальных требований по ресурсам (Ax >= b):")
    actual_resources = A @ res.x
    for i in range(len(b)):
        # Допуск для сравнения чисел с плавающей точкой
        tolerance = 1e-9
        status = "Удовлетворено" if actual_resources[i] >= b[i] - tolerance else "НЕ УДОВЛЕТВОРЕНО"
        print(f"  {resource_names[i]:<25}: Факт {actual_resources[i]:.4f} >= Треб. {b[i]} ({status})")

else:
    print("Статус решения: Задача не решена.")
    print(f"  Сообщение от солвера: {res.message}")
    print(f"  Статус код: {res.status}")

print("="*70)